Souce code for learning [尚硅谷 - Java 设计模式](https://www.youtube.com/playlist?list=PLmOn9nNkQxJH-C-qEI2rpewHTI9ITpMkt)

## 单例模式

`/design/singleton`<br>

- 单例模式保证了系统内存中该类只存在一个对象，节省了系统资源，对于需要频繁创建销毁的对象，使用单例模式能提高系统性能。
- 当实例化一个单例类时，必须使用相应的获取对象的方法，而不是使用 new

## 工厂模式

`/design/factory`

需求：

- 能够订购多个种类的披萨如 Cheese pizza, chicken pizza.
- 实现不同披萨的制作过程：prepare, bake, cut, pack

- 案例 1：
  `/factory/case1`

  - 设计 Pizza 抽象类，不同种类的 pizza 继承这个类，在主程序中根据不同种类调用不同的 Pizza 类。（不采用设计模式）

  - 结论：
    - 简单直接
    - 违反了设计模式原则，不易扩展。

- 案例 2：
  `/factory/case2`

  - 保留原来的 Pizza 类，另外定义一个创建对象的类，由这个类来封装实例化对象的行为。

  - 结论：
    - 使用（简单）工厂模式：由一个工厂对象来决定创建出哪一种产品类的实例。简单工厂模式是工厂模式家族中最简单实用的一种。
    - 当需要大量创建某种对象时，就需要使用工厂模式。

- 案例 3：
  `factory/case3`

  - 需求：在订购披萨时还可以点不同披萨店制作的不同口味的披萨。例如 Domino 的 cheese pizza 或者 Pizzahut 的 Chicken pizza。如果仍然使用简单工厂模式，就需要对不同的披萨店创建不同的工厂类，但这样的实现扩展性，可维护性都不好。于是我们需要使用工厂方法模式。
  - 工厂方法模式介绍：定义一个创建对象的抽象方法，由子类决定要实例化的类。工厂方法模式将对象的实例化推迟到子类。
  - 实现：为不同披萨店的不同口味披萨创建一个类，例如：`DominoCheesePizza`, `DominoChickenPizza`,`PizzahutCheesePizza`, `PizzahutChickenPizza` 继承于 Pizza 类。在`OrderPizza`类中定义`createPizza()`抽象方法，由其子类`OrderPizzahutPizza`和`OrderDominoPizza`来实现该方法。如果用户想订哪家店的 pizza 就调用那家的 Order 类。

- 案例 4：
  `factory/case4`

  - 抽象工厂模式介绍：定义一个 Interface 用于创建相关或有依赖关系的对象簇，而无需指明具体的类。是简单工厂模式和工厂方法模式的整合。在实现中，该模式将工厂抽象成两层：抽象工厂和具体实现工厂的子类。开发者可以根据创建对象类型使用对应的工厂子类。这样可以将单个的简单工厂变成工厂簇，更有利于代码的维护和扩展。(将案例 3 的需求用抽象工厂模式实现)

## 原型模式

`/design/prototype`

需求：有一辆车 car1，厂商是 Toyota，型号是 Camery，年份是 2019 年。现需要创建和这辆车属性完全相同的十辆车。

- 原型模式指通过原型实例创建对象的种类，并且通过拷贝这些原型，创建新的对像而无需知道创建的细节。
- 通过 Java 对象`Object`类的`clone()`方法

## 建造者模式

`/design/builder`

顾名思义，建造者模式的的提出是针对造房子的问题来的。例如造房子有打地基，建造和封顶的过程。但建造不同的房子（普通房，高楼，别墅）步骤虽然一样，但具体实现又各不相同。如何使用建造者模式实现并使得代码易于扩展。

使用建造者模式需涉及到四个角色(类)：

- Product 产品 - 需要建造的产品对象，如房子，汽车等。
- Builder 抽象建造者 - 对于创建 Product 对象的各部件指定的接口或抽象类。回答建造这个产品需要哪些部件(property)和流程(method)
- ImpBuilder 具体建造者，建造 House 还是建造 Highrise 还是建造其他类型房子 - 实现接口，即实现抽象建造者里规定的方法。
- Director 指挥者 - 一个使用 Builder 接口的对象，通过这个对象创建产品。
  通过这四个类，实现了隔离客户和对象的生产过程。

## 适配器模式

`/design/adaptor`

适配器模式来源于生活中的电源变压器(adaptor) 将过高的电压转换成电器可以接受的电压。适配器模式将某个类的接口转换成客户端期望的另一个接口表示，主要目的是增强兼容性，让原本因接口不匹配不能一起工作的两个类可以协同工作。用户只需调用适配器转化出来的目标接口方法，适配器再调用被适配者的相关接口方法。被适配者对用户隐藏。该模式又分为三个小类：类适配器模式、对象适配器模式、接口适配器模式。

## 桥接模式

`/design/bridge`

需求：手机问题。手机有不同的样式 - 折叠式，直立式等，每种不同样式里有不同品牌：Nokia, Samsung, Xiaomi 等。如果对每一种品牌每一个样式都写一个类，会产生大量重复代码，且使得类难以维护。于是就提出了桥接模式。

桥接模式是通过使用封装、聚合或继承等行为让不同的类承担不同的职责。主要特点是将实现和抽象放在两个不同的类层次中，使两个层次可以独立改变以及对他们的功能扩展。

## 装饰者模式

`/design/decorator`

需求：买咖啡问题。咖啡店有各种单品咖啡如：Expresso, Decaf, LongBlack, Capuccino，咖啡还可以加上各种调料如 Milk, Chocolate 等。顾客可以点单品，也可以点单品+调料，需要设计程序根据顾客的点单来计算费用。要求使咖啡在增加新的单品和调料时有良好的扩展性。

装饰者模式是指动态地将新功能附加到对象上，在对象功能扩展方面，比继承更有弹性。

## 组合模式（部分整体模式）

`/design/composite`

需求：院系展示问题。一所大学(University)有学院（College)，学院下有系（Department)，用 OO 的方法展示一个大学的院系组织结构。学校和院系是整体-部分的关系。设计学校、学院、系三个实体，通过组合来实现学校下的院系结构。

组合模式用于处理树形结构的实体，当需要对树上的节点/叶子进行操作时，它能够提供统一的方式，而不用考虑它是节点还是叶子。

组合模式中的角色和职责：

- Component: 组合中对象声明接口，在适当情况下，实现所有类共有的接口默认行为，用于访问和管理 component 子部件，component 可以是抽象类或者接口。
- Leaf: 叶子节点，树形结构的末端（最小实体）
- Composite: 非叶子节点，存储子部件，在 component 接口中实现子部件的相关操作（增加，删除等）

## 外观模式

`design/facade`

需求：家庭影院问题。一个家庭影院有很多设备如播放器，投影仪，屏幕，立体声。每个设备（类）都有各自的功能（方法）。如果需要完成家庭影院功能，需要依次打开各个设备，结束后还需关闭各个设备。如果用主方法直接调用各个设备的方法，容易使调用过程混乱。因此我们需要外观设计模式来解决这个问题：定义一个高层的接口，给各设备的一组接口提供一个一致的界面，来访问子系统中的一群接口。也即通过定义一个一致的接口，屏蔽内部子系统的细节，使得使用者只需跟这个接口发生调用而无需关心子系统的实现细节。

## 享元模式(Flyweight pattern)

`design/flyweight`

享元模式运用共享技术有效地支持大量细粒度的对象。该对象用于解决重复对象的内存浪费问题，当系统中有大量相似对象时，不需要总是创建新对象，而是直接从缓冲池里拿，可以降低系统内存。池技术是该模式一个经典的应用场景，如 String 常量池，数据库连接池，缓冲池等。

享元模式中的角色和职责：

- AbstractFlyweight 抽象类，享元角色。定义对象的外部状态（容易变动的变量）和内部状态（稳定不易变动的变量）的接口或实现。
- Flyweight 具体的享元角色，具体的产品类，需要实现抽象享元角色里的相关业务
- FlyweightFactory 享元工厂类，用于构建一个池容器，同时提供从池中获取对象的相关方法。
- UnsharedConcreteFlyweight 不共享角色，一般不出现在享元工厂类中
- 在使用中，通过 FlyweightFactory 获取 ConcreteFlyweight 对象。

享元模式提出了两个要求：细粒度和共享对象。基于此，对象里的状态可分为外部状态和内部状态。

外部状态是随环境改变，不可共享的状态；内部状态指可以共享出来的信息，存储在享元对象内部且不会随环境改变而改变。

案例：可以将文章发布在不同的平台上：博客、Facebook 或者个人网站上。同一篇文章可以又不同的用于读取。通过享元模式解决该问题，可将文章（不变信息）定义为内部状态，不同的平台定义为外部状态。

## 代理模式

`design/proxy`

代理模式是为对象提供一个替身，以控制对这个对象的访问，即通过代理对象访问目标对象。这样做的好处是：可以在目标对象实现的基础上，增强额外的功能操作，扩展目标对象的功能。被代理的对象可以是远程对象、创建开销大的对象或需要安全控制的对象。主要有三种不同的形式：静态代理、动态代理（接口代理）和 Cglib 代理（可以在内存中动态创建对象，而不需要实现接口）。

静态代理在使用时，需要定义接口或父类，被代理对象（目标对象）与代理对象一起实现相同的接口或继承相同父类。

动态代理中代理对象不需要实现接口，但是目标对象要实现接口。利用 Java JDK 的反射机制来动态创建对象。

静态代理和动态代理中，都需要目标对象实现一个接口。但有时候目标对象就是一个单独的对象，没有接口实现，这个时候可以考虑有 Cglib 代理。它是通过在内存中构建一个子类对象从而实现对目标对象的代理和功能扩展。

## 模板方法模式(Template Method Pattern)

`design/template`

需求：豆浆制作问题。制作豆浆的流程有：选材 - 添加配料 - 浸泡 - 豆浆机制作。通过添加不同的配料，可以制作出不同口味的豆浆。同时这几个步骤对于制作每种不同口味的豆浆都是一致的。对于该问题可以使用模板方法。

实现：在一个抽象类定义一个执行方法（模板），规定了调用的方法和执行顺序。它的子类重写这些方法，但调用时还是调用哪个执行方法。

## 命令模式

`design/command`

在软件设计中，我们会需要向某些对象发送请求，但是不关心请求的接收者是谁，也不知道被请求的操作是哪个。此时，可使用命令模式进行设计。命令模式使得请求调用者和接收者之间解耦，调用者只要调用命令对象的 execute()方法就能让接收者工作，而不必知道接收者是谁，是如何实现的。命令对象负责让接收者执行请求的动作。

容易设计一个命令队列，把命令对象方队队列中，易于扩展。

容易实现对请求的撤销和重做。

不足之处在于，可能导致有过多的命令类，增加了系统的复杂度。

空命令也是一种设计模式，它为我们省去了判空的操作。

## 观察者模式

`design/observer/old` 不使用观察者模式<br>
`design/observer/new` 使用观察者模式改进以上代码

ngrx, observable

观察者模式通常包含一个数据发布类 Subject 和观察者类 Observer

Subject 类中需要实现

- registerObserver 注册观察者
- removeObserver 移除观察者
- notifyObservers 通知所有注册的观察者。根据需求，它可以是更新数据，让用户来取，也可以是实时推送。

## 访问者模式

`design/visitor`

redux

封装一些作用域某种数据结构的个元素的操作，在不改变数据结构的前提下定义作用于这些元素的新的操作。<br>
它可以实现将数据结构和数据操作分离。

实现方法是在被访问的类里面加一个对外提供接待访问者的接口。

应用场景：需要对一个对象结构中的对象进行多种不同操作，同时又要避免让这些操作“污染”这些对象的类。

## 迭代器模式

`design/iterator`

用迭代器模式遍历院系问题（组合模式）

如果我们的集合元素是用不同方式实现的，不论是数组、还是集合类，单个客户端要遍历这些集合元素的时候就要使用多种遍历方式。这时可以使用迭代器模式解决。<br>
迭代器模式提供一种遍历集合元素的统一接口，用一致的方法遍历集合元素而不暴露其内部结构。
